-- Support first!
local support = require "support"

-- Semi-externals.
local s = require "string"
local t = require "taca"

-- Game-related.
local c = require "./common.nelua"
local f = require "./frame.nelua"
local r = require "./resources.nelua"

local function print_frames(name: string, frames: span(r.Rect))
  t.print(name)
  for i, frame in ipairs(frames) do
    t.print(s.format(
      "frame %i: %d %d %d %d",
      i,
      frame.pos[0], frame.pos[1],
      frame.size[0], frame.size[1]
    ))
  end
end

local game: c.Game
local max_instances = 1000

local function start()
  <cexport, codename "start">
  local gc <close> = support.GcStep{}
  -- For kicks, use an example of wasi printing.
  print "Hi from Nelua!"
  print_frames("gem shine", r.gem.shine)
  print_frames("player run", r.player.run)
  t.shader_new(r.shader)
  t.pipeline_new({
    vertex_buffers = {
      {},
      {first_attribute = 1, step = t.Step.Instance},
    },
  })
  game = {
    box_index = t.buffer_new(
      t.BufferKind.Index,
      c.as_bytes((@span(@uint16)){0, 1, 2, 1, 3, 2})
    ),
    box_instance = t.buffer_new(
      t.BufferKind.Vertex,
      {data = nilptr, size = max_instances * #c.Instance}
    ),
    box_vertex = t.buffer_new(
      t.BufferKind.Vertex,
      c.as_bytes((@span(@[2]float32)){
        {-0.5, -0.5}, {-0.5, 0.5}, {0.5, -0.5}, {0.5, 0.5},
      })
    ),
    gem_bindings = {texture = t.image_decode(r.gem.image)},
    max_instances = max_instances,
    player_bindings = {texture = t.image_decode(r.player.image)},
    tiles_bindings = {texture = t.image_decode(r.tiles)},
    uniforms_buffer = t.buffer_new(
      t.BufferKind.Uniform,
      {data = nilptr, size = #c.Uniforms}
    ),
  }
end

local function finish_init()
  t.print("images loaded")
  local function make_bindings(bindings: c.TextureBindings)
    bindings.bindings = t.bindings_new({
      buffers = {game.uniforms_buffer},
      textures = {bindings.texture},
    })
  end
  make_bindings(game.gem_bindings)
  make_bindings(game.player_bindings)
  make_bindings(game.tiles_bindings)
  game.init_finished = true
end

local function update(event: t.EventKind)
  <cexport, codename "update">
  local gc <close> = support.GcStep{}
  switch event do
  case t.EventKind.Frame then
    if game.init_finished then
      f.update(game)
    end
  case t.EventKind.TasksDone then
    finish_init()
  end
end
