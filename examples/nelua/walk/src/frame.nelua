local frame = @record{}

local c = require "./common.nelua"
local d = require "./draw.nelua"
local r = require "./resources.nelua"
local s = require "string"
local t = require "taca"

function frame.update(game: *c.Game)
  -- Window
  local window = t.window_state();
  local viewport_aspect = r.viewport_size[1] / r.viewport_size[0]
  local aspect = window.size[0] / window.size[1] * viewport_aspect
  -- Bindings
  if aspect > 1 then
    game.uniforms.aspect = {1 / aspect, 1}
  else
    game.uniforms.aspect = {1, aspect}
  end
  t.buffer_update(
    game.uniforms_buffer,
    {data = (@pointer(byte))(&game.uniforms), size = #c.Uniforms},
    0
  )
  -- Draw
  local back_source: d.Rect = {
    pos = {0, 0},
    size = {game.back.size[0], game.back.size[1]},
  }
  game.blitter:blit({
    texture = game.back,
    source_rects = {back_source, back_source, back_source},
    view_points = {
      {r.back_offset[0] - game.back.size[0], r.back_offset[1]},
      {r.back_offset[0], r.back_offset[1]},
      {r.back_offset[0] + game.back.size[0], r.back_offset[1]},
    },
  })
  local middle_source: d.Rect = {
    pos = {0, 0},
    size = {game.middle.size[0], game.middle.size[1]},
  }
  game.blitter:blit({
    texture = game.middle,
    source_rects = {middle_source, middle_source, middle_source},
    view_points = {
      {r.middle_offset[0] - game.middle.size[0], r.middle_offset[1]},
      {r.middle_offset[0], r.middle_offset[1]},
      {r.middle_offset[0] + game.middle.size[0], r.middle_offset[1]},
    },
  })
  game.blitter:blit({
    texture = game.tiles,
    -- TODO Actual tiles.
    source_rects = {
      {pos = {0, 0}, size = {game.tiles.size[0], game.tiles.size[1]}},
    },
    view_points = {{0, 0}},
  })
end

return frame
